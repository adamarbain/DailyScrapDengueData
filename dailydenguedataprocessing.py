# -*- coding: utf-8 -*-
"""DailyDengueDataProcessing.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1QnpVOHB9yTaXAm0NDbE3wh1Q_zrmg7jP

Importing packages needed
"""

import requests
import pandas as pd
import datetime
import time
import numpy as np
import matplotlib.pyplot as plt
import geopandas as gpd
from shapely.geometry import Point, Polygon
import folium
import plotly.express as px
import os
import time
from datetime import datetime, timedelta
import pytz
import json

"""Weather API Functions for Open Meteo Integration"""

def fetch_weather_data(latitude, longitude, date, timezone="Asia/Singapore"):
    """
    Fetch weather data from Open Meteo API for a specific location and date
    
    Args:
        latitude (float): Latitude coordinate
        longitude (float): Longitude coordinate
        date (str): Date in format 'DD/MM/YYYY'
        timezone (str): Timezone for the API request
        
    Returns:
        dict: Weather data containing humidity, temperature, and rainfall
    """
    try:
        # Convert date from DD/MM/YYYY to YYYY-MM-DD format
        date_obj = datetime.strptime(date, '%d/%m/%Y')
        formatted_date = date_obj.strftime('%Y-%m-%d')
        
        # Check if date is in the future (Open Meteo archive only has historical data)
        today = datetime.now().date()
        if date_obj.date() > today:
            print(f"Warning: Date {date} is in the future. Using forecast API.")
            return fetch_weather_data_forecast(latitude, longitude, date, timezone)
        elif date_obj.date() == today:
            print(f"Warning: Date {date} is today. Weather data might be incomplete.")
        
        # Construct API URL
        base_url = "https://archive-api.open-meteo.com/v1/archive"
        params = {
            'latitude': latitude,
            'longitude': longitude,
            'start_date': formatted_date,
            'end_date': formatted_date,
            'daily': 'temperature_2m_mean,rain_sum',
            'hourly': 'relative_humidity_2m',
            'timezone': timezone
        }
        
        # Make API request
        response = requests.get(base_url, params=params, timeout=30)
        response.raise_for_status()
        
        data = response.json()
        
        # Extract weather data
        weather_data = {
            'humidity': None,
            'temperature': None,
            'rainfall': None
        }
        
        # Calculate average humidity from hourly data
        if 'hourly' in data and 'relative_humidity_2m' in data['hourly']:
            humidity_values = data['hourly']['relative_humidity_2m']
            if humidity_values and all(v is not None for v in humidity_values):
                weather_data['humidity'] = sum(humidity_values) / len(humidity_values)
        
        # Extract daily temperature and rainfall
        if 'daily' in data:
            if 'temperature_2m_mean' in data['daily'] and data['daily']['temperature_2m_mean']:
                weather_data['temperature'] = data['daily']['temperature_2m_mean'][0]
            
            if 'rain_sum' in data['daily'] and data['daily']['rain_sum']:
                weather_data['rainfall'] = data['daily']['rain_sum'][0]
        
        return weather_data
        
    except requests.exceptions.RequestException as e:
        print(f"Archive API request failed for lat={latitude}, lon={longitude}, date={date}: {str(e)}")
        return {'humidity': None, 'temperature': None, 'rainfall': None}
    except Exception as e:
        print(f"Error processing weather data for lat={latitude}, lon={longitude}, date={date}: {str(e)}")
        return {'humidity': None, 'temperature': None, 'rainfall': None}

def fetch_weather_data_forecast(latitude, longitude, date, timezone="Asia/Singapore"):
    """
    Fetch weather data from Open Meteo Forecast API for future dates
    
    Args:
        latitude (float): Latitude coordinate
        longitude (float): Longitude coordinate
        date (str): Date in format 'DD/MM/YYYY'
        timezone (str): Timezone for the API request
        
    Returns:
        dict: Weather data containing humidity, temperature, and rainfall
    """
    try:
        # Convert date from DD/MM/YYYY to YYYY-MM-DD format
        date_obj = datetime.strptime(date, '%d/%m/%Y')
        formatted_date = date_obj.strftime('%Y-%m-%d')
        
        # Construct Forecast API URL
        base_url = "https://api.open-meteo.com/v1/forecast"
        params = {
            'latitude': latitude,
            'longitude': longitude,
            'daily': 'precipitation_sum,temperature_2m_max,temperature_2m_min',
            'hourly': 'relative_humidity_2m',
            'timezone': timezone,
            'start_date': formatted_date,
            'end_date': formatted_date
        }
        
        # Make API request
        response = requests.get(base_url, params=params, timeout=30)
        response.raise_for_status()
        
        data = response.json()
        
        # Extract weather data
        weather_data = {
            'humidity': None,
            'temperature': None,
            'rainfall': None
        }
        
        # Calculate average humidity from hourly data
        if 'hourly' in data and 'relative_humidity_2m' in data['hourly']:
            humidity_values = data['hourly']['relative_humidity_2m']
            if humidity_values and all(v is not None for v in humidity_values):
                weather_data['humidity'] = sum(humidity_values) / len(humidity_values)
        
        # Extract daily temperature (average of max and min) and rainfall
        if 'daily' in data:
            if 'temperature_2m_max' in data['daily'] and 'temperature_2m_min' in data['daily']:
                temp_max = data['daily']['temperature_2m_max'][0] if data['daily']['temperature_2m_max'] else None
                temp_min = data['daily']['temperature_2m_min'][0] if data['daily']['temperature_2m_min'] else None
                if temp_max is not None and temp_min is not None:
                    weather_data['temperature'] = (temp_max + temp_min) / 2
            
            if 'precipitation_sum' in data['daily'] and data['daily']['precipitation_sum']:
                weather_data['rainfall'] = data['daily']['precipitation_sum'][0]
        
        return weather_data
        
    except requests.exceptions.RequestException as e:
        print(f"Forecast API request failed for lat={latitude}, lon={longitude}, date={date}: {str(e)}")
        return {'humidity': None, 'temperature': None, 'rainfall': None}
    except Exception as e:
        print(f"Error processing forecast weather data for lat={latitude}, lon={longitude}, date={date}: {str(e)}")
        return {'humidity': None, 'temperature': None, 'rainfall': None}

"""Updating Files in GitHub Repository


"""

# ðŸ“Œ Step 1: Define paths relative to the GitHub repository
dengue_hotspot_csv = "dengue_hotspot.csv"
active_dengue_csv = "active_dengue.csv"

# ðŸ“Œ Step 2: Helper function to save DataFrame to CSV
def save_to_csv(df, file_path):
    if df is not None:
        if os.path.exists(file_path):
            df.to_csv(file_path, mode="a", header=False, index=False)  # Append mode
            print(f"Data appended to {file_path}")
        else:
            df.to_csv(file_path, index=False)  # Create new file
        print(f"Data saved to {file_path}")
    else:
        print("No data to save.")

"""API 1 : Fetch UM Location from Idengue.com"""

um_location_url = "https://geocode.arcgis.com/arcgis/rest/services/World/GeocodeServer/findAddressCandidates?SingleLine=Universiti%20Malaya%2C%20Kuala%20Lumpur%2C%20Wilayah%20Persekutuan%20Kuala%20Lumpur%2C%20MYS&f=json&outSR=%7B%22wkid%22%3A102100%7D&outFields=*&magicKey=dHA9MCN0dj00Yjg3MGE5MSNsb2M9Njc4NTA0MTEjbG5nPTExMiNwbD04NTk4Mjk0MCNsYnM9MTQ6NzM1MzMxODMjbG49V29ybGQ%3D&maxLocations=6"

"""API 2 : List of Hotspot"""

hotspot_location_url = "https://sppk.mysa.gov.my/proxy/proxy.php?https://mygis.mysa.gov.my/erica1/rest/services/iDengue/WM_idengue/MapServer/0/query?f=json&where=1%3D1&returnGeometry=true&spatialRel=esriSpatialRelIntersects&outFields=SPWD.AVT_HOTSPOTMINGGUAN.KUMULATIF_KES%2CSPWD.AVT_HOTSPOTMINGGUAN.TEMPOH_WABAK%2CSPWD.AVT_HOTSPOTMINGGUAN.NEGERI%2CSPWD.AVT_HOTSPOTMINGGUAN.DAERAH%2CSPWD.DBO_LOKALITI_POINTS.LOKALITI"

"""API 3 : List of Kawasan Wabak Aktif"""

active_area_url = "https://sppk.mysa.gov.my/proxy/proxy.php?https://mygis.mysa.gov.my/erica1/rest/services/iDengue/WM_idengue/MapServer/4/query?f=json&where=1%3D1&returnGeometry=true&spatialRel=esriSpatialRelIntersects&outFields=SPWD.AVT_WABAK_IDENGUE_NODM.LOKALITI%2CSPWD.AVT_WABAK_IDENGUE_NODM.TOTAL_KES%2CSPWD.AVT_WABAK_IDENGUE_NODM.NEGERI"

"""Defining API Endpoint"""

# Define API endpoints
API_ENDPOINTS = {
    "um_location": um_location_url,
    "hotspot_location_url" : hotspot_location_url,
    "active_area_url" : active_area_url,
}
print(API_ENDPOINTS)

"""Set Timezone to Malaysia (UTC+8)"""

# Set timezone to Malaysia (UTC+8)
malaysia_tz = pytz.timezone("Asia/Kuala_Lumpur")

"""Define functions for processing different API responses"""

def process_api_1(response_json):
    """Process and visualize data for API 1 with interactive hover tooltips."""
    candidates = response_json.get("candidates", [])

    data = [
        {
            "X": c["attributes"].get("X"),
            "Y": c["attributes"].get("Y"),
            "attributes": c["attributes"],
            "location": c["attributes"].get("LongLabel"),
        }
        for c in candidates
    ]

    if not data:
        print("No data available for API 1.")
        return None

    df = pd.DataFrame(data)

    print(f"API 1: Found {len(df)} locations.")
    for idx, row in df.iterrows():
        print(f"Location {idx + 1}: Location -> {row['location']}")

    # Convert attributes dict to string for display
    df["attributes_str"] = df["attributes"].astype(str)

    # Create interactive scatter plot with hover tooltip
    fig = px.scatter(
        df,
        x="X",
        y="Y",
        labels={"X": "Longitude", "Y": "Latitude"},
        title="API 1 - UM Location",
        color_discrete_sequence=["blue"]
    )

    fig.show()

    return df

def process_api_2(response_json, x_target=101.653045, y_target=3.122496, tolerance=0.045):
    """Process and visualize data for API 2 with interactive hover tooltips and weather data."""
    features = response_json.get("features", [])

    filtered_data = []
    current_date = datetime.now(malaysia_tz).strftime('%d/%m/%Y')  # Malaysia Time

    for feature in features:
        attr = feature["attributes"]
        area = attr.get("SPWD.DBO_LOKALITI_POINTS.LOKALITI", "Unknown")
        state = attr.get("SPWD.AVT_HOTSPOTMINGGUAN.NEGERI", "Unknown")
        days_duration = attr.get("SPWD.AVT_HOTSPOTMINGGUAN.TEMPOH_WABAK", 0)
        total_cases = attr.get("SPWD.AVT_HOTSPOTMINGGUAN.KUMULATIF_KES", 0)

        if (x_target - tolerance <= feature["geometry"]["x"] <= x_target + tolerance) and \
           (y_target - tolerance <= feature["geometry"]["y"] <= y_target + tolerance):
            
            # Fetch weather data for this location and date
            print(f"Fetching weather data for hotspot: {area}")
            weather_data = fetch_weather_data(feature["geometry"]["y"], feature["geometry"]["x"], current_date)
            
            filtered_data.append({
                "x": feature["geometry"]["x"],
                "y": feature["geometry"]["y"],
                "date": current_date,
                "area": area,
                "state": state,
                "days_duration": days_duration,
                "total_active_cases": total_cases,
                "humidity": weather_data['humidity'],
                "temperature": weather_data['temperature'],
                "rainfall": weather_data['rainfall']
            })
            
            # Add delay to avoid rate limiting
            time.sleep(1)

    if not filtered_data:
        print("No matching data found within the specified range.")
        return None

    df = pd.DataFrame(filtered_data)

    print(f"API 2: Found {len(df)} dengue hotspot locations.")
    for idx, row in df.iterrows():
        print(f"Hotspot {idx + 1}: Area -> {row['area']}, Cases -> {row['total_active_cases']}")
        print(f"  Weather: Humidity={row['humidity']:.2f}%, Temp={row['temperature']:.2f}Â°C, Rain={row['rainfall']:.2f}mm")

    # Create interactive scatter plot with hover tooltip
    fig = px.scatter(
        df,
        x="x",
        y="y",
        hover_data=["area", "total_active_cases", "humidity", "temperature", "rainfall"],
        labels={"x": "Longitude", "y": "Latitude"},
        title="API 2 - Dengue Hotspots (5KM Radius) with Weather Data",
        color_discrete_sequence=["red"]
    )

    # Add target location as a marker
    fig.add_scatter(
        x=[x_target],
        y=[y_target],
        mode="markers",
        marker=dict(size=10, color="black", symbol="x"),
        name="Target Location"
    )

    fig.show()

    # Save to Google Drive
    save_to_csv(df, dengue_hotspot_csv)

    return df

def calculate_centroid(rings):
    """Calculate the centroid of a polygon given its rings."""
    all_x = [point[0] for ring in rings for point in ring]
    all_y = [point[1] for ring in rings for point in ring]
    return np.mean(all_x), np.mean(all_y)

def process_api_3(response_json, x_target=101.653045, y_target=3.122496, tolerance=0.045):
    """Process and visualize data for API 3, filtering based on polygon centroid with weather data."""
    features = response_json.get("features", [])

    filtered_data = []
    current_date = datetime.now(malaysia_tz).strftime('%d/%m/%Y')  # Malaysia Time
    
    for feature in features:
        rings = feature.get("geometry", {}).get("rings", [])
        if not rings:
            continue

        centroid_x, centroid_y = calculate_centroid(rings)

        # Extract relevant attributes
        attributes = feature.get("attributes", {})
        location = attributes.get("SPWD.AVT_WABAK_IDENGUE_NODM.LOKALITI", "null")
        state = attributes.get("SPWD.AVT_WABAK_IDENGUE_NODM.NEGERI", "null")
        total_cases = attributes.get("SPWD.AVT_WABAK_IDENGUE_NODM.TOTAL_KES", 0)

        if (x_target - tolerance <= centroid_x <= x_target + tolerance) and (y_target - tolerance <= centroid_y <= y_target + tolerance):
            
            # Fetch weather data for this location and date
            print(f"Fetching weather data for active area: {location}")
            weather_data = fetch_weather_data(centroid_y, centroid_x, current_date)
            
            filtered_data.append({
                "attributes": feature["attributes"],
                "centroid_x": centroid_x,
                "centroid_y": centroid_y,
                "date": current_date,
                "location": location,
                "state": state,
                "total_active_cases": total_cases,
                "humidity": weather_data['humidity'],
                "temperature": weather_data['temperature'],
                "rainfall": weather_data['rainfall']
            })
            
            # Add delay to avoid rate limiting
            time.sleep(1)

    if not filtered_data:
        print("No matching data found within the specified range.")
        return None

    df = pd.DataFrame(filtered_data)

    print(f"API 3: Found {len(df)} active area centroids.")
    for idx, row in df.iterrows():
        print(f"Centroid {idx + 1}: Location: {row['location']}, Total Cases: {row['total_active_cases']}")
        print(f"  Weather: Humidity={row['humidity']:.2f}%, Temp={row['temperature']:.2f}Â°C, Rain={row['rainfall']:.2f}mm")

    # Convert attributes dict to string for display
    df["attributes_str"] = df["attributes"].astype(str)

    # Create interactive scatter plot with hover tooltip
    fig = px.scatter(
        df,
        x="centroid_x",
        y="centroid_y",
        hover_data=["location", "state", "total_active_cases", "humidity", "temperature", "rainfall"],
        labels={"centroid_x": "Longitude", "centroid_y": "Latitude"},
        title="API 3 - Active Area Centroids (5KM Radius) with Weather Data"
    )

    # Add target location as a marker
    fig.add_scatter(
        x=[x_target],
        y=[y_target],
        mode="markers",
        marker=dict(size=10, color="black", symbol="x"),
        name="Target Location"
    )

    fig.show()

    # Drop the unwanted columns
    df = df.drop(columns=["attributes", "attributes_str"])

    # Save to Google Drive
    save_to_csv(df, active_dengue_csv)

    return df

"""Mapping APIs to their respective processing functions"""

PROCESSING_FUNCTIONS = {
    "um_location": process_api_1,
    "hotspot_location_url": process_api_2,
    "active_area_url": process_api_3
}
print(PROCESSING_FUNCTIONS)

"""Define function to fetch and store the data"""

def fetch_and_store(api_name, url):
    """Fetch data from API and store it using the appropriate processing function."""
    try:
        response = requests.get(url)
        response.raise_for_status()
        data = response.json()

        if api_name in PROCESSING_FUNCTIONS:
            df = PROCESSING_FUNCTIONS[api_name](data)
            print(f"Data from {api_name} processed successfully!")
            return df
        else:
            print(f"No processing function defined for {api_name}")
    except Exception as e:
        print(f"Error fetching data from {api_name}: {e}")

"""Weather Data Summary Function"""

def display_weather_summary(df, api_name):
    """Display weather data summary for the processed data."""
    if df is None or len(df) == 0:
        print(f"No weather data available for {api_name}")
        return
    
    print(f"\n=== Weather Data Summary for {api_name} ===")
    
    # Check if weather columns exist
    weather_columns = ['humidity', 'temperature', 'rainfall']
    available_weather_cols = [col for col in weather_columns if col in df.columns]
    
    if not available_weather_cols:
        print("No weather data columns found in the dataset.")
        return
    
    for col in available_weather_cols:
        if df[col].notna().any():
            print(f"{col.capitalize()}:")
            print(f"  - Records with data: {df[col].notna().sum()}/{len(df)}")
            print(f"  - Average: {df[col].mean():.2f}")
            print(f"  - Min: {df[col].min():.2f}")
            print(f"  - Max: {df[col].max():.2f}")
        else:
            print(f"{col.capitalize()}: No data available")
    
    print("=" * 50)

"""Run daily data fetching with weather integration"""

if __name__ == "__main__":
    print("=" * 60)
    print("DAILY DENGUE DATA PROCESSING WITH WEATHER INTEGRATION")
    print("=" * 60)
    print("Fetching dengue data and weather information...")
    print("Note: This process may take time due to weather API calls.")
    print("=" * 60)
    
    results = {}
    
    for api_name, url in API_ENDPOINTS.items():
        print(f"\nFetching data from {api_name}...")
        df = fetch_and_store(api_name, url)
        results[api_name] = df
        
        # Display weather summary if applicable
        if api_name in ["hotspot_location_url", "active_area_url"] and df is not None:
            display_weather_summary(df, api_name)
    
    print("\n" + "=" * 60)
    print("DAILY DATA PROCESSING COMPLETED")
    print("=" * 60)
    
    # Final summary
    total_hotspots = len(results.get("hotspot_location_url", pd.DataFrame())) if results.get("hotspot_location_url") is not None else 0
    total_active_areas = len(results.get("active_area_url", pd.DataFrame())) if results.get("active_area_url") is not None else 0
    
    print(f"Total dengue hotspots found: {total_hotspots}")
    print(f"Total active outbreak areas found: {total_active_areas}")
    print(f"Data saved to: {dengue_hotspot_csv} and {active_dengue_csv}")
    print("All data now includes weather information (humidity, temperature, rainfall)")
